
//approach 1
// using recursion 

class Solution {
public:
    int m, n;

    int solve(int i, int j, string &word1, string &word2){
        if(i == word1.size()){
            if(j < n){
                return n-j;
            }
            return 0;
        }
        if(j == word2.size()){
            if(i < m){
                return m-i;
            }
            return 0;
        }

        int insert = 0 , del = 0, rep = 0;

        if(word1[i] == word2[j]){
            return solve(i+1, j+1, word1, word2);
        }
        else{
            
            rep = 1+solve(i+1, j+1, word1, word2);
            del = 1+solve(i+1, j, word1, word2);
            insert = 1+solve(i, j+1, word1, word2);   
        }
        return min(insert, min(del, rep));
    }


    int minDistance(string word1, string word2) {
        m = word1.size();
        n = word2.size();
        return solve(0, 0, word1, word2);
    }
};

-----------------------------------------------------------------------------------------------------------------------------
//Approach 2
//recursion + memoization

class Solution {
public:
    int m, n;
    int t[501][501];

    int solve(int i, int j, string &word1, string &word2){
        if(i == word1.size()){
            if(j < n){
                return n-j;
            }
            return 0;
        }
        if(j == word2.size()){
            if(i < m){
                return m-i;
            }
            return 0;
        }

        if(t[i][j] != -1) return t[i][j];

        int insert = 0 , del = 0, rep = 0;

        if(word1[i] == word2[j]){
            return t[i][j] = solve(i+1, j+1, word1, word2);
        }
        else{
            
            rep = 1+solve(i+1, j+1, word1, word2);
            del = 1+solve(i+1, j, word1, word2);
            insert = 1+solve(i, j+1, word1, word2);   
        }
        return t[i][j] = min(insert, min(del, rep));
    }


    int minDistance(string word1, string word2) {
        m = word1.size();
        n = word2.size();

        memset(t, -1, sizeof(t));
        return solve(0, 0, word1, word2);
    }
};

------------------------------------------------------------------------------------------------------------------------------
//Approach - 3 (Bottom up)

class Solution {
public:
    //Bottom up

    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();

        vector<vector<int>>t(m+1, vector<int>(n+1));

        for(int i = 0; i <= m; i++){
            for(int j = 0; j <= n; j++){
                if(i == 0 || j == 0){
                    t[i][j] = i+j;
                }else if(word1[i-1] == word2[j-1]){
                    t[i][j] = t[i-1][j-1];
                }else{
                    int rep = 1+t[i-1][j-1];
                    int del = 1+t[i-1][j];
                    int ins = 1+t[i][j-1];
                    t[i][j] = min({rep, del, ins});
                }
                
            }
        }

        return t[m][n];
    }
};




