//Ques - 132. Palindrome Partitioning II

//Approach 1
//recursion
class Solution {
public:
    bool isPalindrome(int i, int j, string &s){
        while(i < j){
            if(s[i] != s[j]){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }

    int solve(int idx, string &s){
        if(idx == s.size()){
            return 0;
        }

        int ans = INT_MAX;

        for(int j = idx; j < s.size(); j++){
            if(isPalindrome(idx, j, s)){
                int cut = 1+solve(j+1, s);
                ans = min(ans, cut);
            }
            
        }

        return ans;

    }

    int minCut(string s) {
        int n = s.size();
        return solve(0, s)-1;
    }
};

----------------------------------------------------------------------------------------------------------------------------
//Approach 2 (TLE) recursion + memoization
class Solution {
public:
    bool isPalindrome(int i, int j, string &s){
        while(i < j){
            if(s[i] != s[j]){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }

    int t[2001][2001];

    int solve(int i, int j, string &s){
        if(i >= j) return 0;

        if(t[i][j] != -1) return t[i][j];

        if(isPalindrome(i, j, s)){
            return 0;
        }

        int ans = INT_MAX;
        for(int k = i; k <= j-1; k++){
            int temp = 1+solve(i, k, s)+solve(k+1, j, s);
            
            ans = min(ans, temp);
        }
        return t[i][j] = ans;
    }


    int minCut(string s) {
        int n = s.size();
        memset(t, -1, sizeof(t));
        return solve(0, n-1, s);   
    }
};

----------------------------------------------------------------------------------------------------------------------------
//Approach 3
//recursion + memoization
class Solution {
public:
    bool isPalindrome(int i, int j, string &s){
        while(i < j){
            if(s[i] != s[j]){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }

    int t[2001] ;

    int solve(int idx, string &s){
        if(idx == s.size()){
            return 0;
        }
        if(t[idx] != -1) return t[idx];

        int ans = INT_MAX;

        for(int j = idx; j < s.size(); j++){
            if(isPalindrome(idx, j, s)){
                int cut = 1+solve(j+1, s);
                ans = min(ans, cut);
            }
            
        }

        return t[idx] = ans;

    }

    int minCut(string s) {
        int n = s.size();
        memset(t, -1, sizeof(t));
        return solve(0, s)-1;
    }
};
---------------------------------------------------------------------------------------------------------------------------
///Approach - 4
//Bottom up
class Solution {
public:
    int dp[2001];

    int solve(int idx, string &s, vector<vector<bool>>&t){
        if(idx == s.size()){
            return 0;
        }

        if(dp[idx] != -1) return dp[idx];

        int ans = INT_MAX;

        for(int j = idx; j < s.size(); j++){
            if(t[idx][j]){
                int cut = 1+solve(j+1, s, t);
                ans = min(ans, cut);
            }           
        }

        return dp[idx] = ans;

    }

    int minCut(string s) {
        int n = s.size();
        vector<vector<bool>>t(n, vector<bool>(n));

        for(int i = 0; i < n; i++){
            t[i][i] = true;
        }
        for(int len = 2; len <= n; len++){
            for(int i = 0; i+len-1 < n; i++){
                int j = i+len-1;
                if(i+1 == j){
                    t[i][j] = s[i] == s[j];
                }else{
                    t[i][j] = s[i] == s[j] && t[i+1][j-1];
                }
            }
        }

        memset(dp, -1, sizeof(dp));

        return solve(0, s, t)-1;
    }
};
