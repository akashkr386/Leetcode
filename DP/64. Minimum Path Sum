//Ques - 64. Minimum Path Sum

//Approach - 1

class Solution {
public:
    int m, n;

    int t[201][201];

    int solve(int i, int j, vector<vector<int>>& grid){
        if(i >= m || j >= n) return 0;

        if(i == m-1 && j == n-1) return grid[i][j];

        if(t[i][j] != -1) return t[i][j];
        //yadi i == m-1

        if(i == m-1){
            return t[i][j] = grid[i][j] + solve(i, j+1, grid);
        }
        else if(j == n-1){
            return t[i][j] = grid[i][j] + solve(i+1, j, grid);
        }

        else{
            return t[i][j] = grid[i][j] + min(solve(i+1, j, grid), solve(i, j+1, grid));
        }

    }

    int minPathSum(vector<vector<int>>& grid) {
        m = grid.size();
        n = grid[0].size();

        memset(t, -1, sizeof(t));

        return solve(0, 0, grid);

    }
};

----------------------------------------------------------------------------------------------------------------------------
//Approach - 2

class Solution {
public:

    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        vector<vector<int>>dp(m, vector<int>(n));
        dp[0][0] = grid[0][0];

        for(int i = 1; i < m; i++) dp[i][0] = grid[i][0] + dp[i-1][0];
        for(int j = 1; j < n; j++) dp[0][j] = grid[0][j] + dp[0][j-1];

        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = grid[i][j] + min(dp[i][j-1], dp[i-1][j]);
            }
        }

        return dp[m-1][n-1];

    }
};

----------------------------------------------------------------------------------------------------------------------------
//Approach - 3 
//space optimization 

class Solution {
public:

    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        vector<int>dp(n);
        dp[0] = grid[0][0];

        for(int j = 1; j < n; j++) dp[j] =  grid[0][j]+dp[j-1];

        int sum = 0;
        for(int i = 1; i < m; i++){
            dp[0] += grid[i][0];
            for(int j = 1; j < n; j++){
                dp[j] = grid[i][j] + min(dp[j], dp[j-1]);
            }
        }

        return dp[n-1];

    }
};

