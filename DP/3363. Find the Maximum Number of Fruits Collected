//Ques - 3363. Find the Maximum Number of Fruits Collected

//Approach 1 
//recursion (TLE)
class Solution {
public:
    int n;

    int solve1(int i, int j, vector<vector<int>>& fruits){
        int ans = 0;
        for(int i = 0; i < n; i++){
            ans += fruits[i][i];
        }
        return ans;
    }

    int solve2(int i, int j, vector<vector<int>>& fruits){
        if(i >= n || j >= n || j < 0) return 0;
        
        if(i == n-1 && j == n-1 ){
            return 0;
        }

        if(i == j || i < j) return 0;
        
        int right = fruits[i][j] + solve2(i, j+1, fruits);
        int diag = fruits[i][j] + solve2(i-1, j+1, fruits); 
        int digD = fruits[i][j] + solve2(i+1, j+1, fruits);

        return max({right, diag, digD});
    }

    int solve3(int i, int j, vector<vector<int>>& fruits){
        if(i >= n || j >= n || j < 0) return 0;
        
        if(i == n-1 && j == n-1){
            return 0;
        }
        if(i == j || i > j) return 0;
      
        int right = fruits[i][j] + solve3(i+1, j-1, fruits);
        int diag = fruits[i][j] + solve3(i+1, j, fruits);
        int digD = fruits[i][j] + solve3(i+1, j+1, fruits);

        return max({right, diag, digD});
    }



    int maxCollectedFruits(vector<vector<int>>& fruits) {
        n = fruits.size();

        int ans1 = solve1(0, 0, fruits);
        // fruits[n-1][n-1] = 0;
        int ans2 = solve2(n-1, 0, fruits);
        int ans3 = solve3(0, n-1, fruits);

        return ans1+ans2+ans3;
    }
};
--------------------------------------------------------------------------------------------------------------------------
//Approach -2 
//recursion + memoization

class Solution {
public:
    int n;
    vector<vector<int>>t;

    int solve1(int i, int j, vector<vector<int>>& fruits){
        int ans = 0;
        for(int i = 0; i < n; i++){
            ans += fruits[i][i];
        }
        return ans;
    }

    int solve2(int i, int j, vector<vector<int>>& fruits){
        if(i >= n || j >= n || j < 0) return 0;
        
        if(i == n-1 && j == n-1 ){
            return 0;
        }


        if(i == j || i < j) return 0;

        if(t[i][j] != -1) return t[i][j];
        
        int right = fruits[i][j] + solve2(i, j+1, fruits);
        int diag = fruits[i][j] + solve2(i-1, j+1, fruits); 
        int digD = fruits[i][j] + solve2(i+1, j+1, fruits);

        return t[i][j] = max({right, diag, digD});
    }

    int solve3(int i, int j, vector<vector<int>>& fruits){
        if(i >= n || j >= n || j < 0) return 0;
        
        if(i == n-1 && j == n-1){
            return 0;
        }
        if(i == j || i > j) return 0;
        if(t[i][j] != -1) return t[i][j];

      
        int right = fruits[i][j] + solve3(i+1, j-1, fruits);
        int diag = fruits[i][j] + solve3(i+1, j, fruits);
        int digD = fruits[i][j] + solve3(i+1, j+1, fruits);

        return t[i][j] = max({right, diag, digD});
    }



    int maxCollectedFruits(vector<vector<int>>& fruits) {
        n = fruits.size();

        t.resize(n, vector<int>(n, -1));

        int ans1 = solve1(0, 0, fruits);
        // fruits[n-1][n-1] = 0;
        int ans2 = solve2(n-1, 0, fruits);
        int ans3 = solve3(0, n-1, fruits);

        return ans1+ans2+ans3;
    }
};
---------------------------------------------------------------------------------------------------------------------------
//Approach 3
// Bottom up approach

//Approach-2 - (Bottom Up)
//T.C : O(n^2)
//S.C : O(n^2)

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        vector<vector<int>> t(n, vector<int>(n, 0));
        //t[i][j] = max fruits collected till [i][j]

        //child1Collect - Diagonal elements
        int result = 0;
        for(int i = 0; i < n; i++) {
            result += fruits[i][i];
        }


        //Before child2 and child3, nullify the cells which can't be visited by child2 and child3
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                if(i < j && i+j < n-1) {
                    t[i][j] = 0;
                } else if(i > j && i+j < n-1) {
                    t[i][j] = 0;
                } else {
                    t[i][j] = fruits[i][j];
                }
            }
        }


        //child2 collect fruits
        //cells upper to diagonal : i < j
        for(int i = 1; i < n; i++) {
            for(int j = i+1; j < n; j++) {
                t[i][j] += max({t[i-1][j-1], t[i-1][j], (j+1 < n) ? t[i-1][j+1] : 0});
            }
        }

        //child3 collect fruits
        //cells upper to diagonal : i > j
        for(int j = 1; j < n; j++) {
            for(int i = j+1; i < n; i++) {
                t[i][j] += max({t[i-1][j-1], t[i][j-1], (i+1 < n) ? t[i+1][j-1] : 0});
            }
        }

        return result + t[n-2][n-1] + t[n-1][n-2];

    }
};

