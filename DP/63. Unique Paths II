//Ques- 63. Unique Paths II

//approach 1:

class Solution {
public:
    int m, n;
    int t[101][101];

    int solve(int down, int right, vector<vector<int>>&grid){
        if(down == m-1 && right == n-1) return 1;
        if(down >= m || right >= n || grid[down][right] == 1) return 0;

        if(t[down][right] != -1) return t[down][right];

        int d = solve(down+1, right, grid);
        int r = solve(down, right+1, grid);

        return t[down][right] = d+r;
    }

    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        m = obstacleGrid.size();
        n = obstacleGrid[0].size();

        if(obstacleGrid[m-1][n-1] == 1) return 0;

        memset(t, -1, sizeof(t));

        return solve(0, 0, obstacleGrid);
    }
};

----------------------------------------------------------------------------------------------------------------------------
//Approach - 2
//Bottom up 

class Solution {
public:

    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();

        if(obstacleGrid[m-1][n-1] == 1) return 0;

        vector<vector<int>>dp(m, vector<int>(n));

        bool notObs = true;
        for(int i = 0; i < n; i++){
            if(obstacleGrid[0][i] == 1){
                notObs = false;
            }
            dp[0][i] = notObs;
        }
        notObs = true;
        for(int i = 0; i < m; i++){
            if(obstacleGrid[i][0] == 1){
                notObs = false;
            }
            dp[i][0] = notObs;
        }
        
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                if(obstacleGrid[i][j] == 1) dp[i][j] = 0;
                else
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
};

-----------------------------------------------------------------------------------------------------------------------------
//Approach - 3
//Bottom up with space optimization

class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();

        vector<int> dp(n, 0);

        // start cell
        dp[0] = (obstacleGrid[0][0] == 0);

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0; // obstacle blocks path
                } else if (j > 0) {
                    dp[j] += dp[j-1];
                }
            }
        }

        return dp[n-1];
    }
};
