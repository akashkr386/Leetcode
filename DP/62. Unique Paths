//Ques - 62. Unique Paths


//Approach - 1

class Solution {
public:
    int totalPath(int sr, int sc, int er, int ec, vector<vector<int>>&dp){
        if(sr > er || sc > ec) return 0;
        if(sr == er && sc == ec) return 1;
        if(dp[sr][sc]!=-1) return dp[sr][sc];
        int rightWays = totalPath(sr , sc+1, er, ec, dp);
        int downWays = totalPath(sr+1, sc, er, ec, dp);
        return dp[sr][sc] = rightWays+downWays;
    }
    int uniquePaths(int m, int n) {
        vector<vector<int>>dp(m, vector<int>(n, -1));
       int ans = totalPath(0, 0 ,m-1 ,n-1, dp);
       return ans; 
    }
};

--------------------------------------------------------------------------------------------------------------------------
//Approach - 2

class Solution {
public:
    int uniquePaths(int n, int m) {
        int dp[n][m];
        dp[0][0] = 1;
        for(int i=1; i<m; i++) dp[0][i] = 1; 
        for(int i=1; i<n; i++) dp[i][0] = 1;

        for(int i=1; i<n; i++) {
            for(int j=1; j<m; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[n-1][m-1];
    }
};

---------------------------------------------------------------------------------------------------------------------------
//Approach - 3
//space optimization

class Solution {
public:
    int uniquePaths(int n, int m) {
        int dp[m];
        // base case
        dp[0] = 1;
        for(int i=1; i<m; i++) dp[i] = 1; 

        // fill db array
        for(int i=1; i<n; i++) {
            for(int j=1; j<m; j++) {
                dp[j] = dp[j] + dp[j-1];
                // dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1];
    }
};
